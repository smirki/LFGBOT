"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const knub_command_manager_1 = require("knub-command-manager");
function applyCooldownToCommand(commandData, cooldown) {
    commandData.config.extra.cooldown = cooldown.time;
    commandData.config.extra.cooldownPermission = cooldown.permission;
}
function applyRequiredPermissionToCommand(commandData, permissionData) {
    commandData.config.extra.requiredPermission = permissionData.permission;
}
function applyRequiredPermissionToEvent(eventData, permissionData) {
    eventData.requiredPermission = permissionData.permission;
}
function applyLockToCommand(commandData, lockData) {
    commandData.config.extra.locks = lockData.locks;
}
function applyLockToEvent(eventData, lockData) {
    eventData.locks = lockData.locks;
}
/**
 * PLUGINS: Turn a class method into a command handler
 */
function CommandDecorator(trigger, parameters = [], config = {}) {
    return (target, propertyKey, descriptor) => {
        if (!Reflect.hasMetadata("commands", target, propertyKey)) {
            Reflect.defineMetadata("commands", [], target, propertyKey);
        }
        const commands = Reflect.getMetadata("commands", target, propertyKey);
        const finalParameters = typeof parameters === "string" ? knub_command_manager_1.parseParameters(parameters) : parameters;
        config.extra = config.extra || {};
        const commandData = {
            trigger,
            parameters: finalParameters,
            config,
            _prop: propertyKey
        };
        // Apply existing cooldowns
        const cooldownData = Reflect.getMetadata("cooldown", target, propertyKey);
        if (cooldownData)
            applyCooldownToCommand(commandData, cooldownData);
        // Apply existing permission requirements
        const permissionData = Reflect.getMetadata("requiredPermission", target, propertyKey);
        if (permissionData)
            applyRequiredPermissionToCommand(commandData, permissionData);
        // Apply existing locks
        const lockData = Reflect.getMetadata("locks", target, propertyKey);
        if (lockData)
            applyLockToCommand(commandData, lockData);
        commands.push(commandData);
    };
}
/**
 * PLUGINS: Turn a class method into an event listener
 */
function OnEventDecorator(eventName, restrict, ignoreSelf, requiredPermission, locks = []) {
    return (target, propertyKey, descriptor) => {
        if (!Reflect.hasMetadata("events", target, propertyKey)) {
            Reflect.defineMetadata("events", [], target, propertyKey);
        }
        const events = Reflect.getMetadata("events", target, propertyKey) || [];
        const eventData = {
            eventName,
            restrict,
            ignoreSelf,
            requiredPermission,
            locks,
            _prop: propertyKey
        };
        // Apply existing permission requirements
        const permissionData = Reflect.getMetadata("requiredPermission", target, propertyKey);
        if (permissionData)
            applyRequiredPermissionToEvent(eventData, permissionData);
        // Apply existing locks
        const lockData = Reflect.getMetadata("locks", target, propertyKey);
        if (lockData)
            applyLockToEvent(eventData, lockData);
        events.push(eventData);
    };
}
/**
 * PLUGINS: Augments command handlers and event listeners by adding a permission requirement
 */
function PermissionDecorator(permission) {
    return (target, propertyKey, descriptor) => {
        const permissionData = {
            permission,
            _prop: propertyKey
        };
        Reflect.defineMetadata("requiredPermission", permissionData, target, propertyKey);
        // Apply to existing commands
        const commands = Reflect.getMetadata("commands", target, propertyKey) || [];
        commands.forEach(cmd => applyRequiredPermissionToCommand(cmd, permissionData));
        // Apply to existing events
        const events = Reflect.getMetadata("events", target, propertyKey) || [];
        events.forEach(ev => applyRequiredPermissionToEvent(ev, permissionData));
    };
}
/**
 * PLUGINS: Specify which locks the command handler or event listener should wait for and lock during its execution
 */
function LockDecorator(locks) {
    return (target, propertyKey, descriptor) => {
        const lockData = {
            locks,
            _prop: propertyKey
        };
        Reflect.defineMetadata("locks", lockData, target, propertyKey);
        // Apply to existing commands
        const commands = Reflect.getMetadata("commands", target, propertyKey) || [];
        commands.forEach(cmd => applyLockToCommand(cmd, lockData));
        // Apply to existing events
        const events = Reflect.getMetadata("events", target, propertyKey) || [];
        events.forEach(ev => applyLockToEvent(ev, lockData));
    };
}
/**
 * PLUGINS: Specify a cooldown for a command
 */
function CooldownDecorator(time, permission = null) {
    return (target, propertyKey, descriptor) => {
        const cooldownData = {
            time,
            permission,
            _prop: propertyKey
        };
        Reflect.defineMetadata("cooldown", cooldownData, target, propertyKey);
        // Apply to existing commands
        const commands = Reflect.getMetadata("commands", target, propertyKey) || [];
        commands.forEach(cmd => applyCooldownToCommand(cmd, cooldownData));
    };
}
exports.default = {
    command: CommandDecorator,
    event: OnEventDecorator,
    permission: PermissionDecorator,
    lock: LockDecorator,
    cooldown: CooldownDecorator
};
//# sourceMappingURL=decorators.js.map