"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const eris_1 = require("eris");
const knub_command_manager_1 = require("knub-command-manager");
const utils_1 = require("./utils");
const commandUtils_1 = require("./commandUtils");
const configUtils_1 = require("./configUtils");
const PluginError_1 = require("./PluginError");
const CooldownManager_1 = require("./CooldownManager");
const baseParameterTypes_1 = require("./baseParameterTypes");
const pluginUtils_1 = require("./pluginUtils");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
/**
 * Base class for Knub plugins
 */
class Plugin {
    constructor(bot, guildId, guildConfig, pluginOptions, runtimePluginName, knub, locks) {
        this.bot = bot;
        this.guildId = guildId;
        this.guildConfig = guildConfig;
        this.pluginOptions = pluginOptions;
        this.runtimePluginName = runtimePluginName;
        this.knub = knub;
        this.locks = locks;
    }
    /**
     * Run basic initialization and the plugin-defined onLoad() function
     */
    async runLoad() {
        // Basic initialization
        this.guild = this.guildId ? this.bot.guilds.get(this.guildId) : null;
        this.commandManager = new knub_command_manager_1.CommandManager({
            prefix: this.guildConfig.prefix || commandUtils_1.getDefaultPrefix(this.bot),
            types: Object.assign(Object.assign(Object.assign({}, baseParameterTypes_1.baseParameterTypes), this.knub.getCustomArgumentTypes()), this.constructor.customArgumentTypes)
        });
        this.commandHandlers = new Map();
        this.eventHandlers = new Map();
        this.cooldowns = new CooldownManager_1.CooldownManager();
        // Run plugin-defined onLoad() function
        await this.onLoad();
        // Register decorator-defined commands
        const decoratorCommands = pluginUtils_1.getPluginDecoratorCommands(this.constructor);
        for (let command of decoratorCommands) {
            command = lodash_clonedeep_1.default(command);
            this.addCommand(command.trigger, command.parameters, this[command._prop].bind(this), command.config);
        }
        // Register decorator-defined event listeners
        const decoratorEventListeners = pluginUtils_1.getPluginDecoratorEventListeners(this.constructor);
        for (let eventListener of decoratorEventListeners) {
            eventListener = lodash_clonedeep_1.default(eventListener);
            this.on(eventListener.eventName, this[eventListener._prop].bind(this), eventListener.restrict, eventListener.ignoreSelf, eventListener.requiredPermission, eventListener.locks);
        }
        this.registerCommandMessageListener();
    }
    /**
     * Clear event handlers and run plugin-defined onUnload() function
     */
    async runUnload() {
        this.clearEventHandlers();
        await this.onUnload();
        this.clearMergedOptions();
    }
    /**
     * Code to run when the plugin is loaded
     */
    onLoad() {
        // Implemented by plugin
    }
    /**
     * Code to run when the plugin is unloaded
     */
    onUnload() {
        // Implemented by plugin
    }
    /**
     * Function to resolve custom override criteria in the plugin's config.
     * Remember to also set TCustomOverrideCriteria appropriately.
     */
    matchCustomOverrideCriteria(criteria, matchParams) {
        // Implemented by plugin
        return true;
    }
    /**
     * Registers the message listener for commands
     */
    registerCommandMessageListener() {
        this.on("messageCreate", this.runCommandFromMessage.bind(this));
    }
    /**
     * Returns this plugin's default configuration
     */
    getDefaultOptions() {
        // Implemented by plugin
        return {};
    }
    /**
     * Returns the plugin's default options merged with its loaded options
     */
    getMergedOptions() {
        if (!this.mergedPluginOptions) {
            const defaultOptions = this.getDefaultOptions();
            this.mergedPluginOptions = {
                config: configUtils_1.mergeConfig(defaultOptions.config || {}, this.pluginOptions.config || {}),
                overrides: this.pluginOptions.replaceDefaultOverrides
                    ? this.pluginOptions.overrides || []
                    : (this.pluginOptions.overrides || []).concat(defaultOptions.overrides || [])
            };
        }
        return this.mergedPluginOptions;
    }
    /**
     * Resets the cached mergedPluginOptions object
     */
    clearMergedOptions() {
        this.mergedPluginOptions = null;
    }
    /**
     * Returns the base config from the merged options that's currently being used without applying any overrides
     */
    getConfig() {
        const mergedOptions = this.getMergedOptions();
        return mergedOptions.config;
    }
    /**
     * Returns the plugin's config with overrides matching the given match params applied to it
     */
    getMatchingConfig(matchParams = {}) {
        const message = matchParams.message;
        // Passed userId -> passed member's id -> passed message's author's id
        const userId = matchParams.userId ||
            (matchParams.member && matchParams.member.id) ||
            (message && message.author && message.author.id);
        // Passed channelId -> passed message's channel id
        const channelId = matchParams.channelId || (message && message.channel && message.channel.id);
        // Passed category id -> passed message's channel's category id
        const categoryId = matchParams.categoryId || (message && message.channel && message.channel.parentID);
        // Passed member -> passed message's member
        const member = matchParams.member || (message && message.member);
        // Passed level -> passed member's level
        const level = matchParams.level != null ? matchParams.level : member ? this.getMemberLevel(member) : null;
        // Passed roles -> passed member's roles
        const memberRoles = matchParams.memberRoles || (member && member.roles);
        const finalMatchParams = {
            level,
            userId,
            channelId,
            categoryId,
            memberRoles
        };
        const mergedOptions = this.getMergedOptions();
        return configUtils_1.getMatchingPluginConfig(mergedOptions, finalMatchParams, this.matchCustomOverrideCriteria.bind(this));
    }
    /**
     * Returns the plugin's config with overrides matching the given member id and channel id applied to it
     */
    getConfigForMemberIdAndChannelId(memberId, channelId) {
        const guildId = this.bot.channelGuildMap[channelId];
        const guild = this.bot.guilds.get(guildId);
        const member = guild.members.get(memberId);
        const level = member ? this.getMemberLevel(member) : null;
        const categoryId = guild.channels.has(channelId) ? guild.channels.get(channelId).parentID : null;
        return this.getMatchingConfig({
            level,
            userId: memberId,
            channelId,
            categoryId,
            memberRoles: member ? member.roles : []
        });
    }
    /**
     * Returns the plugin's config with overrides matching the given message applied to it
     */
    getConfigForMsg(msg) {
        const level = msg.member ? this.getMemberLevel(msg.member) : null;
        return this.getMatchingConfig({
            level,
            userId: msg.author.id,
            channelId: msg.channel.id,
            categoryId: msg.channel.parentID,
            memberRoles: msg.member ? msg.member.roles : []
        });
    }
    /**
     * Returns the plugin's config with overrides matching the given channel applied to it
     */
    getConfigForChannel(channel) {
        return this.getMatchingConfig({
            channelId: channel.id,
            categoryId: channel.parentID
        });
    }
    /**
     * Returns the plugin's config with overrides matching the given user applied to it
     */
    getConfigForUser(user) {
        return this.getMatchingConfig({
            userId: user.id
        });
    }
    /**
     * Returns the plugin's config with overrides matching the given member applied to it
     */
    getConfigForMember(member) {
        const level = this.getMemberLevel(member);
        return this.getMatchingConfig({
            level,
            userId: member.user.id,
            memberRoles: member.roles
        });
    }
    /**
     * Returns the member's permission level
     */
    getMemberLevel(member) {
        if (this.guild.ownerID === member.id) {
            return 99999;
        }
        const levels = this.guildConfig.levels;
        for (const id in levels) {
            if (member.id === id || (member.roles && member.roles.includes(id))) {
                return levels[id];
            }
        }
        return 0;
    }
    /**
     * Wrapper for getting a matching config and checking the permission value is true
     */
    hasPermission(requiredPermission, matchParams) {
        const config = this.getMatchingConfig(matchParams);
        return utils_1.get(config, requiredPermission) === true;
    }
    addCommand(trigger, parameters, handler, config) {
        config.preFilters = config.preFilters || [];
        config.preFilters.unshift(
        // Make sure the command is in a guild channel unless explicitly allowed for DMs
        (cmd, context) => {
            if (context.message.channel instanceof eris_1.PrivateChannel) {
                if (!cmd.config.extra.allowDMs) {
                    return false;
                }
            }
            else if (!(context.message.channel instanceof eris_1.GuildChannel)) {
                return false;
            }
            return true;
        }, 
        // Check required permissions
        (cmd, context) => {
            const requiredPermission = cmd.config.extra.requiredPermission;
            if (requiredPermission && !this.hasPermission(requiredPermission, { message: context.message })) {
                return false;
            }
            return true;
        });
        config.postFilters = config.postFilters || [];
        config.postFilters.unshift(
        // Check for cooldowns
        (cmd, context) => {
            if (cmd.config.extra.cooldown) {
                const cdKey = `${cmd.id}-${context.message.author.id}`;
                let cdApplies = true;
                if (cmd.config.extra.cooldownPermission) {
                    cdApplies = !this.hasPermission(cmd.config.extra.cooldownPermission, { message: context.message });
                }
                if (cdApplies && this.cooldowns.isOnCooldown(cdKey)) {
                    // We're on cooldown
                    return false;
                }
                this.cooldowns.setCooldown(cdKey, cmd.config.extra.cooldown);
            }
            return true;
        }, 
        // Wait for locks, if any, and bail out if the lock has been interrupted
        async (cmd, context) => {
            if (cmd.config.extra.locks) {
                cmd.config.extra._lock = await this.locks.acquire(cmd.config.extra.locks);
                if (cmd.config.extra._lock.interrupted) {
                    return false;
                }
            }
            return true;
        });
        const command = this.commandManager.add(trigger, parameters, config);
        this.commandHandlers.set(command.id, handler);
    }
    removeCommand(id) {
        this.commandManager.remove(id);
        this.commandHandlers.delete(id);
    }
    getRegisteredCommands() {
        const commands = this.commandManager.getAll();
        return commands.map(command => ({ command, handler: this.commandHandlers.get(command.id) }));
    }
    /**
     * Adds a guild-specific event listener for the given event
     */
    on(eventName, listener, restrict = "guild", ignoreSelf = true, requiredPermission = null, locks = []) {
        if (!this.eventHandlers.has(eventName)) {
            this.eventHandlers.set(eventName, []);
        }
        // Create a wrapper for the listener that checks:
        // 1) That the event matches the restrict param (guild/dm/group)
        // 2) That we ignore our own events if ignoreSelf is true
        // 3) That the event's guild (if present) matches this plugin's guild
        // 4) If the event has a message, that the message author has the permissions to trigger events
        const wrappedListener = async (...args) => {
            const guild = utils_1.eventToGuild[eventName] ? utils_1.eventToGuild[eventName](...args) : null;
            const user = utils_1.eventToUser[eventName] ? utils_1.eventToUser[eventName](...args) : null;
            const channel = utils_1.eventToChannel[eventName] ? utils_1.eventToChannel[eventName](...args) : null;
            const message = utils_1.eventToMessage[eventName] ? utils_1.eventToMessage[eventName](...args) : null;
            // Restrictions
            if (restrict === "dm" && !(channel instanceof eris_1.PrivateChannel))
                return;
            if (restrict === "guild" && !guild)
                return;
            if (restrict === "group" && !(channel instanceof eris_1.GroupChannel))
                return;
            // Ignore self
            if (ignoreSelf && user === this.bot.user)
                return;
            // Guild check
            if (this.guildId && guild && guild.id !== this.guildId)
                return;
            // Permission check
            if (requiredPermission) {
                const userId = user && user.id;
                const channelId = channel && channel.id;
                const categoryId = channel && channel.parentID;
                if (!this.hasPermission(requiredPermission, {
                    message,
                    userId,
                    channelId,
                    categoryId
                })) {
                    return;
                }
            }
            let lock;
            if (locks.length) {
                lock = await this.locks.acquire(locks);
                if (lock.interrupted)
                    return;
                // Add the lock as the final argument for the listener
                args.push(lock);
            }
            const timerDone = listener.name !== "bound runCommandsInMessage" ? this.knub.startPerformanceDebugTimer(listener.name) : null;
            // Call the original listener
            try {
                await listener(...args);
            }
            catch (err) {
                throw new PluginError_1.PluginError(err);
            }
            finally {
                if (lock)
                    lock.unlock();
                timerDone && timerDone(); // tslint:disable-line
            }
        };
        // The listener is registered on both the Eris client and our own Map that we use to unregister listeners on unload
        this.bot.on(eventName, wrappedListener);
        this.eventHandlers.get(eventName).push(wrappedListener);
        // Return a function to clear the listener
        const removeListener = () => {
            this.off(eventName, wrappedListener);
        };
        return removeListener;
    }
    /**
     * Removes the given listener from the event
     */
    off(eventName, listener) {
        this.bot.off(eventName, listener);
        if (this.eventHandlers.has(eventName)) {
            const thisEventNameHandlers = this.eventHandlers.get(eventName);
            thisEventNameHandlers.splice(thisEventNameHandlers.indexOf(listener), 1);
        }
    }
    /**
     * Clears all event listeners registered with on()
     */
    clearEventHandlers() {
        for (const [eventName, listeners] of this.eventHandlers) {
            listeners.forEach(listener => {
                this.bot.off(eventName, listener);
            });
        }
        this.eventHandlers.clear();
    }
    /**
     * Checks whether the specified plugin for the same guild as this plugin exists
     * Useful for interoperability between plugins
     */
    hasPlugin(name) {
        const guildData = this.knub.getGuildData(this.guildId);
        return guildData.loadedPlugins.has(name);
    }
    /**
     * Returns the specified plugin for the same guild as this plugin
     * Useful for interoperability between plugins
     */
    getPlugin(name) {
        const guildData = this.knub.getGuildData(this.guildId);
        return guildData.loadedPlugins.get(name);
    }
    /**
     * Finds the first matching command in the message and runs it.
     * Replies with command usage info if there are errors.
     */
    async runCommandFromMessage(msg) {
        // Ignore messages without text (e.g. images, embeds, etc.)
        if (msg.content == null || msg.content.trim() === "") {
            return;
        }
        const matchedCommand = await this.commandManager.findMatchingCommand(msg.content, {
            message: msg,
            bot: this.bot,
            plugin: this
        });
        if (matchedCommand == null) {
            // No command matched the message
            return;
        }
        if (knub_command_manager_1.findMatchingCommandResultHasError(matchedCommand)) {
            // There was a matching command, but we encountered an error
            const usageLine = commandUtils_1.getCommandSignature(matchedCommand.command);
            this.sendErrorMessage(msg.channel, `${matchedCommand.error}\nUsage: \`${usageLine}\``);
            return;
        }
        const timerDone = this.knub.startPerformanceDebugTimer(`cmd: ${matchedCommand.triggers[0].source} (${matchedCommand.id})`);
        await this.runCommand(msg, matchedCommand, matchedCommand.args, matchedCommand.opts);
        timerDone();
    }
    /**
     * Runs the specified command
     */
    async runCommand(msg, cmd, args = {}, opts = {}) {
        const handler = this.commandHandlers.get(cmd.id);
        const argValueMap = Object.entries(args).reduce((map, [key, arg]) => {
            map[key] = arg.value;
            return map;
        }, {});
        const optValueMap = Object.entries(opts).reduce((map, [key, opt]) => {
            map[key] = opt.value;
            return map;
        }, {});
        await handler(msg, Object.assign(Object.assign({}, argValueMap), optValueMap), cmd);
    }
    sendErrorMessage(channel, body) {
        this.knub.sendErrorMessage(channel, body);
    }
    sendSuccessMessage(channel, body) {
        this.knub.sendSuccessMessage(channel, body);
    }
}
exports.Plugin = Plugin;
Plugin.customArgumentTypes = {};
//# sourceMappingURL=Plugin.js.map