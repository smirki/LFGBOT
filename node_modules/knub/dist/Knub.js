"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const fs = fs_1.default.promises;
const logger_1 = require("./logger");
const Plugin_1 = require("./Plugin");
const events_1 = __importDefault(require("events"));
const utils_1 = require("./utils");
const perf_hooks_1 = require("perf_hooks");
const LockManager_1 = require("./LockManager");
class IExtendedPlugin extends Plugin_1.Plugin {
}
class IExtendedGlobalPlugin extends Plugin_1.Plugin {
}
const defaultKnubParams = {
    plugins: [],
    globalPlugins: [],
    options: {}
};
class Knub extends events_1.default {
    constructor(client, userArgs) {
        super();
        this.globalPlugins = new Map();
        this.loadedGlobalPlugins = new Map();
        this.plugins = new Map();
        this.guilds = new Map();
        const args = Object.assign({}, defaultKnubParams, userArgs);
        this.bot = client;
        this.globalLocks = new LockManager_1.LockManager();
        this.performanceDebugItems = [];
        args.globalPlugins.forEach(globalPlugin => {
            if (globalPlugin.pluginName == null) {
                throw new Error(`No plugin name specified for global plugin ${globalPlugin.name}`);
            }
            if (this.globalPlugins.has(globalPlugin.pluginName)) {
                throw new Error(`Duplicate plugin name: ${globalPlugin.pluginName}`);
            }
            this.globalPlugins.set(globalPlugin.pluginName, globalPlugin);
        });
        args.plugins.forEach(plugin => {
            if (plugin.pluginName == null) {
                throw new Error(`No plugin name specified for plugin ${plugin.name}`);
            }
            if (this.plugins.has(plugin.pluginName)) {
                throw new Error(`Duplicate plugin name: ${plugin.pluginName}`);
            }
            this.plugins.set(plugin.pluginName, plugin);
        });
        const defaultOptions = {
            // Default JSON config files
            async getConfig(id) {
                const configFile = id ? `${id}.json` : "global.json";
                const configPath = path_1.default.join("config", configFile);
                try {
                    await fs.access(configPath);
                }
                catch (e) {
                    return {};
                }
                const json = await fs.readFile(configPath, { encoding: "utf8" });
                return JSON.parse(json);
            },
            // By default, load all plugins that haven't been explicitly disabled
            getEnabledPlugins: async (guildId, guildConfig) => {
                const plugins = guildConfig.plugins || {};
                return Array.from(this.plugins.keys()).filter(pluginName => {
                    return !plugins[pluginName] || plugins[pluginName].enabled !== false;
                });
            },
            canLoadGuild: () => true,
            customArgumentTypes: {},
            sendErrorMessageFn(channel, body) {
                channel.createMessage({
                    embed: {
                        description: body,
                        color: parseInt("ee4400", 16)
                    }
                });
            },
            sendSuccessMessageFn(channel, body) {
                channel.createMessage({
                    embed: {
                        description: body,
                        color: parseInt("1ac600", 16)
                    }
                });
            }
        };
        this.options = Object.assign(Object.assign({}, defaultOptions), args.options);
        if (this.options.logFn) {
            logger_1.setLoggerFn(this.options.logFn);
        }
    }
    async run() {
        this.bot.on("debug", async (str) => {
            logger_1.logger.debug(`[ERIS] ${str}`);
        });
        this.bot.on("error", async (err) => {
            logger_1.logger.error(`[ERIS] ${String(err)}`);
        });
        const loadErrorTimeout = setTimeout(() => {
            logger_1.logger.info("This is taking unusually long. Check the token?");
        }, 30 * 1000);
        this.bot.on("ready", async () => {
            clearTimeout(loadErrorTimeout);
            logger_1.logger.info("Bot connected!");
            logger_1.logger.info("Loading global plugins...");
            await this.loadGlobalConfig();
            await this.loadAllGlobalPlugins();
            logger_1.logger.info("Loading guilds..");
            this.bot.on("guildAvailable", (guild) => {
                logger_1.logger.info(`Joined guild: ${guild.id}`);
                this.loadGuild(guild.id);
            });
            this.bot.on("guildUnavailable", (guild) => {
                logger_1.logger.info(`Left guild: ${guild.id}`);
                this.unloadGuild(guild.id);
            });
            await this.loadAllGuilds();
            logger_1.logger.info("All loaded, the bot is now running!");
            this.emit("loadingFinished");
        });
        await this.bot.connect();
    }
    async loadAllGuilds() {
        const guilds = Array.from(this.bot.guilds.values());
        const loadPromises = guilds.map(guild => this.loadGuild(guild.id));
        await Promise.all(loadPromises);
    }
    /**
     * Initializes the specified guild's config and loads its plugins
     */
    async loadGuild(guildId) {
        if (this.guilds.has(guildId)) {
            // Prevent loading the same guild twice
            return;
        }
        if (!this.bot.guilds.has(guildId)) {
            // Only load the guild if we're actually in the guild
            return;
        }
        const guildData = {
            config: null,
            id: guildId,
            loadedPlugins: new Map(),
            locks: new LockManager_1.LockManager()
        };
        this.guilds.set(guildId, guildData);
        // Can we load this guild?
        if (!(await this.options.canLoadGuild(guildData.id))) {
            this.guilds.delete(guildId);
            return;
        }
        // Load config
        guildData.config = await this.options.getConfig(guildData.id);
        // Load plugins
        const enabledPlugins = await this.options.getEnabledPlugins.call(this, guildData.id, guildData.config);
        const loadPromises = enabledPlugins.map(async (pluginName) => {
            const plugin = await this.loadPlugin(guildData.id, pluginName, guildData.config);
            if (!plugin)
                return;
            guildData.loadedPlugins.set(pluginName, plugin);
        });
        await Promise.all(loadPromises);
        this.emit("guildLoaded", guildId);
    }
    /**
     * Unloads all plugins in the specified guild, and removes the guild from the list of loaded guilds
     */
    async unloadGuild(guildId) {
        const guildData = this.guilds.get(guildId);
        if (!guildData) {
            return;
        }
        for (const plugin of guildData.loadedPlugins.values()) {
            await this.unloadPlugin(plugin);
        }
        this.guilds.delete(guildId);
        this.emit("guildUnloaded", guildId);
    }
    async reloadGuild(guildId) {
        await this.unloadGuild(guildId);
        await this.loadGuild(guildId);
    }
    getGuildData(guildId) {
        return this.guilds.get(guildId);
    }
    getLoadedGuilds() {
        return Array.from(this.guilds.values());
    }
    async loadPlugin(guildId, pluginName, guildConfig) {
        if (!this.plugins.has(pluginName)) {
            throw new Error(`Unknown plugin: ${pluginName}`);
        }
        const pluginOptions = utils_1.get(guildConfig, `plugins.${pluginName}`) || {};
        const PluginClass = this.plugins.get(pluginName);
        const guildLocks = this.guilds.get(guildId).locks;
        const plugin = new PluginClass(this.bot, guildId, guildConfig, pluginOptions, pluginName, this, guildLocks);
        try {
            await plugin.runLoad();
        }
        catch (e) {
            if (!(e instanceof Error))
                throw e;
            logger_1.logger.warn(`Could not load plugin ${pluginName} for guild ${guildId}: ${e.stack}`);
            return;
        }
        this.emit("guildPluginLoaded", guildId, pluginName, plugin);
        return plugin;
    }
    async unloadPlugin(plugin) {
        await plugin.runUnload();
        this.emit("guildPluginUnloaded", plugin.guildId, plugin.runtimePluginName, plugin);
    }
    async reloadPlugin(plugin) {
        await this.unloadPlugin(plugin);
        const guild = this.guilds.get(plugin.guildId);
        await this.loadPlugin(guild.id, plugin.runtimePluginName, guild.config);
    }
    getPlugins() {
        return this.plugins;
    }
    async loadGlobalPlugin(pluginName) {
        if (!this.globalPlugins.has(pluginName)) {
            throw new Error(`Unknown global plugin: ${pluginName}`);
        }
        const pluginOptions = utils_1.get(this.globalConfig, `plugins.${pluginName}`) || {};
        const PluginClass = this.globalPlugins.get(pluginName);
        const plugin = new PluginClass(this.bot, null, this.globalConfig, pluginOptions, pluginName, this, this.globalLocks);
        try {
            await plugin.runLoad();
        }
        catch (e) {
            if (!(e instanceof Error))
                throw e;
            logger_1.logger.warn(`Could not load global plugin ${pluginName}: ${e.stack}`);
            return;
        }
        this.loadedGlobalPlugins.set(pluginName, plugin);
        this.emit("globalPluginLoaded", pluginName);
        return plugin;
    }
    async unloadGlobalPlugin(plugin) {
        this.loadedGlobalPlugins.delete(plugin.runtimePluginName);
        await plugin.runUnload();
        this.emit("globalPluginUnloaded", plugin.runtimePluginName);
    }
    async reloadGlobalPlugin(plugin) {
        await this.unloadGlobalPlugin(plugin);
        await this.loadGlobalPlugin(plugin.runtimePluginName);
    }
    async reloadAllGlobalPlugins() {
        const loadedGlobalPlugins = Array.from(this.loadedGlobalPlugins.values());
        for (const plugin of loadedGlobalPlugins) {
            await this.reloadGlobalPlugin(plugin);
        }
    }
    async loadAllGlobalPlugins() {
        for (const name of this.globalPlugins.keys()) {
            this.loadGlobalPlugin(name);
        }
    }
    getGlobalPlugins() {
        return this.globalPlugins;
    }
    async reloadGlobalConfig() {
        await this.loadGlobalConfig();
        await this.reloadAllGlobalPlugins();
    }
    async loadGlobalConfig() {
        this.globalConfig = await this.options.getConfig("global");
    }
    getGlobalConfig() {
        return this.globalConfig;
    }
    performanceDebugEnabled() {
        return this.options.performanceDebug && this.options.performanceDebug.enabled;
    }
    logPerformanceDebugItem(time, description) {
        if (!this.performanceDebugEnabled()) {
            return;
        }
        const threshold = this.options.performanceDebug.threshold || 0;
        if (time < threshold)
            return;
        const size = this.options.performanceDebug.size || 30;
        this.performanceDebugItems.push(`[${Math.ceil(time)}ms] ${description}`);
        if (this.performanceDebugItems.length > size) {
            this.performanceDebugItems.splice(0, 1);
        }
    }
    startPerformanceDebugTimer(description) {
        if (!this.performanceDebugEnabled()) {
            return utils_1.noop;
        }
        const startTime = perf_hooks_1.performance.now();
        return () => {
            const totalTime = perf_hooks_1.performance.now() - startTime;
            this.logPerformanceDebugItem(totalTime, description);
        };
    }
    getPerformanceDebugItems() {
        return Array.from(this.performanceDebugItems);
    }
    getCustomArgumentTypes() {
        return this.options.customArgumentTypes || {};
    }
    sendErrorMessage(channel, body) {
        this.options.sendErrorMessageFn(channel, body);
    }
    sendSuccessMessage(channel, body) {
        this.options.sendSuccessMessageFn(channel, body);
    }
}
exports.Knub = Knub;
//# sourceMappingURL=Knub.js.map