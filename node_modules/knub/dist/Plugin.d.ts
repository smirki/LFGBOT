import { Channel, Client, Guild, Member, Message, User, TextableChannel } from "eris";
import { IParameter, ICommandDefinition, IArgumentMap, IMatchedOptionMap } from "knub-command-manager";
import { IBasePluginConfig, IGuildConfig, IPartialPluginOptions, IPluginOptions } from "./configInterfaces";
import { ArbitraryFunction } from "./utils";
import { ICommandContext, ICommandExtraData, ICustomArgumentTypesMap, IPluginCommandConfig, IPluginCommandDefinition, TCommandHandler } from "./commandUtils";
import { Knub } from "./Knub";
import { IMatchParams } from "./configUtils";
import { LockManager } from "./LockManager";
import { CooldownManager } from "./CooldownManager";
export interface IExtendedMatchParams extends IMatchParams {
    channelId?: string;
    member?: Member;
    message?: Message;
}
export interface IRegisteredCommand {
    command: IPluginCommandDefinition;
    handler: TCommandHandler;
}
/**
 * Base class for Knub plugins
 */
export declare class Plugin<TConfig extends {} = IBasePluginConfig, TCustomOverrideCriteria extends {} = {}> {
    static pluginName: string;
    static pluginInfo: any;
    protected static customArgumentTypes: ICustomArgumentTypesMap;
    readonly guildId: string;
    guild: Guild;
    runtimePluginName: string;
    protected readonly bot: Client;
    protected readonly guildConfig: IGuildConfig;
    protected readonly pluginOptions: IPartialPluginOptions;
    protected mergedPluginOptions: IPluginOptions;
    protected readonly knub: Knub;
    protected locks: LockManager;
    private commandManager;
    private commandHandlers;
    protected eventHandlers: Map<string, any[]>;
    protected cooldowns: CooldownManager;
    constructor(bot: Client, guildId: string, guildConfig: IGuildConfig, pluginOptions: IPartialPluginOptions, runtimePluginName: string, knub: Knub, locks: LockManager);
    /**
     * Run basic initialization and the plugin-defined onLoad() function
     */
    runLoad(): Promise<any>;
    /**
     * Clear event handlers and run plugin-defined onUnload() function
     */
    runUnload(): Promise<any>;
    /**
     * Code to run when the plugin is loaded
     */
    protected onLoad(): any;
    /**
     * Code to run when the plugin is unloaded
     */
    protected onUnload(): any;
    /**
     * Function to resolve custom override criteria in the plugin's config.
     * Remember to also set TCustomOverrideCriteria appropriately.
     */
    protected matchCustomOverrideCriteria(criteria: TCustomOverrideCriteria, matchParams: IMatchParams): boolean;
    /**
     * Registers the message listener for commands
     */
    protected registerCommandMessageListener(): void;
    /**
     * Returns this plugin's default configuration
     */
    protected getDefaultOptions(): IPluginOptions<TConfig, TCustomOverrideCriteria>;
    /**
     * Returns the plugin's default options merged with its loaded options
     */
    protected getMergedOptions(): IPluginOptions<TConfig, TCustomOverrideCriteria>;
    /**
     * Resets the cached mergedPluginOptions object
     */
    protected clearMergedOptions(): void;
    /**
     * Returns the base config from the merged options that's currently being used without applying any overrides
     */
    protected getConfig(): TConfig;
    /**
     * Returns the plugin's config with overrides matching the given match params applied to it
     */
    protected getMatchingConfig(matchParams?: IExtendedMatchParams): TConfig;
    /**
     * Returns the plugin's config with overrides matching the given member id and channel id applied to it
     */
    protected getConfigForMemberIdAndChannelId(memberId: string, channelId: string): TConfig;
    /**
     * Returns the plugin's config with overrides matching the given message applied to it
     */
    protected getConfigForMsg(msg: Message): TConfig;
    /**
     * Returns the plugin's config with overrides matching the given channel applied to it
     */
    protected getConfigForChannel(channel: Channel): TConfig;
    /**
     * Returns the plugin's config with overrides matching the given user applied to it
     */
    protected getConfigForUser(user: User): TConfig;
    /**
     * Returns the plugin's config with overrides matching the given member applied to it
     */
    protected getConfigForMember(member: Member): TConfig;
    /**
     * Returns the member's permission level
     */
    protected getMemberLevel(member: Partial<Member>): number;
    /**
     * Wrapper for getting a matching config and checking the permission value is true
     */
    protected hasPermission(requiredPermission: string, matchParams: IExtendedMatchParams): boolean;
    protected addCommand(trigger: string | RegExp, parameters: string | IParameter[], handler: TCommandHandler, config: IPluginCommandConfig): void;
    protected removeCommand(id: number): void;
    getRegisteredCommands(): IRegisteredCommand[];
    /**
     * Adds a guild-specific event listener for the given event
     */
    protected on(eventName: string, listener: ArbitraryFunction, restrict?: string, ignoreSelf?: boolean, requiredPermission?: string, locks?: string | string[]): () => void;
    /**
     * Removes the given listener from the event
     */
    protected off(eventName: string, listener: ArbitraryFunction): void;
    /**
     * Clears all event listeners registered with on()
     */
    protected clearEventHandlers(): void;
    /**
     * Checks whether the specified plugin for the same guild as this plugin exists
     * Useful for interoperability between plugins
     */
    protected hasPlugin(name: string): boolean;
    /**
     * Returns the specified plugin for the same guild as this plugin
     * Useful for interoperability between plugins
     */
    protected getPlugin<T extends Plugin>(name: string): T;
    /**
     * Finds the first matching command in the message and runs it.
     * Replies with command usage info if there are errors.
     */
    protected runCommandFromMessage(msg: Message): Promise<void>;
    /**
     * Runs the specified command
     */
    protected runCommand(msg: Message, cmd: ICommandDefinition<ICommandContext, ICommandExtraData>, args?: IArgumentMap, opts?: IMatchedOptionMap): Promise<void>;
    protected sendErrorMessage(channel: TextableChannel, body: string): void;
    protected sendSuccessMessage(channel: TextableChannel, body: string): void;
}
