"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const DEFAULT_LOCK_TIMEOUT = 10 * 1000;
const LOCK_GC_TIMEOUT = 120 * 1000;
class Lock {
    constructor(oldLocks = [], lockTimeout = DEFAULT_LOCK_TIMEOUT) {
        // A new lock can be built by combining the state from previous locks
        // For now, this means if any of the old locks was interrupted, the new one is as well
        this.interrupted = oldLocks.some(l => l && l.interrupted);
        this.unlockPromise = new Promise(resolve => {
            this.resolve = resolve;
        });
        setTimeout(() => this.unlock(), lockTimeout);
    }
    unlock() {
        this.resolve(this);
    }
    interrupt() {
        this.interrupted = true;
        this.unlock();
    }
}
exports.Lock = Lock;
class LockManager {
    constructor(lockTimeout = DEFAULT_LOCK_TIMEOUT) {
        this.locks = new Map();
        this.lockTimeout = lockTimeout;
        this.lockGCTimeouts = new Map();
    }
    acquire(keys, lockTimeout = null) {
        if (!Array.isArray(keys))
            keys = [keys];
        if (lockTimeout == null)
            lockTimeout = this.lockTimeout;
        keys.forEach(key => {
            clearTimeout(this.lockGCTimeouts.get(key));
            this.lockGCTimeouts.delete(key);
        });
        // To acquire a lock, we must first wait for all matching old locks to resolve
        const oldLockPromises = keys.reduce((lockPromises, key) => (this.locks.has(key) ? [...lockPromises, this.locks.get(key)] : lockPromises), []);
        const newLockPromise = Promise.all(oldLockPromises)
            .then(oldLocks => {
            // And then we have to wait for these old locks to unlock as well
            return Promise.all(oldLocks.map(l => l.unlockPromise));
        })
            .then(unlockedOldLocks => {
            // And *then* we can return a new lock
            keys.forEach(key => {
                this.lockGCTimeouts.set(key, setTimeout(() => {
                    this.locks.delete(key);
                    this.lockGCTimeouts.delete(key);
                }, LOCK_GC_TIMEOUT));
            });
            return new Lock(unlockedOldLocks, lockTimeout);
        });
        for (const key of keys) {
            this.locks.set(key, newLockPromise);
        }
        return newLockPromise;
    }
    setLockTimeout(ms) {
        this.lockTimeout = ms;
    }
}
exports.LockManager = LockManager;
//# sourceMappingURL=LockManager.js.map