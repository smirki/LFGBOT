import { ICommandConfig, ICommandDefinition, ICommandManagerOptions, IFindMatchingCommandError, ITryMatchingCommandResult, TTypeConverterFn, ITryMatchingArgumentsToSignatureResult, TOrError, TFindMatchingCommandResult, TParseableSignature, TSignature } from "./types";
import { TParsedArguments } from "./parseArguments";
export declare class CommandManager<TContext = null, TConfigExtra = null, TConfig extends ICommandConfig<TContext, TConfigExtra> = ICommandConfig<TContext, TConfigExtra>> {
    protected commands: ICommandDefinition<TContext, TConfigExtra>[];
    protected defaultPrefix: RegExp | null;
    protected originalDefaultPrefix: string | RegExp | null;
    protected types: {
        [key: string]: TTypeConverterFn<TContext>;
    };
    protected defaultType: string;
    protected optionPrefixes: string[];
    protected commandId: number;
    constructor(opts: ICommandManagerOptions<TContext>);
    /**
     * Adds a command to the manager.
     *
     * Examples:
     *
     * add("add", "<first:number> <second:number>")
     *   Adds a command called "add" with two required arguments.
     *   These arguments are added in an easily-readable string format.
     *
     * add("echo", [{name: "text", type: "string", catchAll: true}])
     *   Adds a command with a required argument "text" that captures the entire rest of the arguments.
     *   These arguments are added in a more programmable, array of objects format.
     *
     * add("mul", "<numbers:number...>")
     *   Adds a command with a required, repeatable argument "numbers".
     */
    add(trigger: string | RegExp, parameters?: TParseableSignature, config?: TConfig): ICommandDefinition<TContext, TConfigExtra>;
    remove(defOrId: ICommandDefinition<TContext, TConfigExtra> | number): void;
    /**
     * Get a command's definition by its id
     */
    get(id: number): ICommandDefinition<TContext, TConfigExtra> | undefined;
    /**
     * Get an array of all registered command definitions in the command manager
     */
    getAll(): Array<ICommandDefinition<TContext, TConfigExtra>>;
    /**
     * Returns the prefix that is currently being used as the default prefix for added commands.
     * This is the internal RegExp representation of the passed "prefix" option.
     */
    getDefaultPrefix(): RegExp | null;
    /**
     * Returns the original prefix passed in CommandManager options, if any
     */
    getOriginalDefaultPrefix(): string | RegExp | null;
    /**
     * Find the first matching command in the given string, if any.
     * This function returns a promise to support async types and filter functions.
     */
    findMatchingCommand(str: string, ...context: TContext extends null ? [null?] : [TContext]): Promise<TFindMatchingCommandResult<TContext, TConfigExtra> | null>;
    /**
     * Type guard to check if the findMatchingCommand result had an error in a way that TypeScript understands it and
     * narrows types properly afterwards.
     *
     * This is part of the manager class as otherwise the TContext and TExtra types would have to be specified any time
     * this function is used. Having it here in the manager lets us set those automatically.
     */
    findMatchingCommandResultHasError(result: TFindMatchingCommandResult<TContext, TConfigExtra>): result is IFindMatchingCommandError<TContext, TConfigExtra>;
    /**
     * Attempts to match the given command to a string.
     */
    protected tryMatchingCommand(command: ICommandDefinition<TContext, TConfigExtra>, str: string, context: TContext): Promise<TOrError<ITryMatchingCommandResult<TContext, TConfigExtra>> | null>;
    protected tryMatchingArgumentsToSignature(command: ICommandDefinition<TContext, TConfigExtra>, parsedArguments: TParsedArguments, signature: TSignature, str: string, context: TContext): Promise<TOrError<ITryMatchingArgumentsToSignatureResult>>;
    protected convertToArgumentType(value: any, type: string, context: TContext): any;
}
