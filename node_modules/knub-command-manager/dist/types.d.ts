export interface ICommandManagerOptions<TContext> {
    prefix?: RegExp | string;
    types?: {
        [key: string]: TTypeConverterFn<TContext>;
    };
    defaultType?: string;
    optionPrefixes?: string[];
}
export interface IParameter {
    name: string;
    type: string;
    required?: boolean;
    def?: any;
    rest?: boolean;
    catchAll?: boolean;
}
export declare type TSignature = IParameter[];
export declare type TParseableSignature = string | TSignature;
export interface IArgument {
    parameter: IParameter;
    value: any;
    usesDefaultValue?: true;
}
export interface IArgumentMap {
    [name: string]: IArgument;
}
export declare type TBaseOption = {
    name: string;
    shortcut?: string;
};
export declare type TOptionWithValue = TBaseOption & {
    type?: string;
    required?: boolean;
    def?: any;
    isSwitch?: false;
};
export declare type TSwitchOption = TBaseOption & {
    isSwitch: true;
};
export declare type TOption = TOptionWithValue | TSwitchOption;
export declare function isSwitchOption(option: TOption): option is TSwitchOption;
export interface IMatchedOption {
    option: TOption;
    value: any;
    usesDefaultValue?: true;
}
export interface IMatchedOptionMap {
    [name: string]: IMatchedOption;
}
export declare type TPreFilterFn<TContext, TExtra> = (command: ICommandDefinition<TContext, TExtra>, context: TContext) => boolean | Promise<boolean>;
export declare type TPostFilterFn<TContext, TExtra> = (command: IMatchedCommand<TContext, TExtra>, context: TContext) => boolean | Promise<boolean>;
export interface ICommandConfig<TContext, TExtra> {
    prefix?: string | RegExp;
    options?: TOption[];
    aliases?: string[];
    overloads?: TParseableSignature[];
    preFilters?: TPreFilterFn<TContext, TExtra>[];
    postFilters?: TPostFilterFn<TContext, TExtra>[];
    extra?: TExtra;
}
export interface ICommandDefinition<TContext, TExtra> {
    id: number;
    prefix: RegExp | null;
    originalPrefix: string | RegExp | null;
    triggers: RegExp[];
    originalTriggers: Array<string | RegExp>;
    signatures: TSignature[];
    options: TOption[];
    preFilters: TPreFilterFn<TContext, TExtra>[];
    postFilters: TPostFilterFn<TContext, TExtra>[];
    config: ICommandConfig<TContext, TExtra> | null;
}
export declare type TError = {
    error: string;
};
export declare type TOrError<T> = T | TError;
export declare function isError(value: TOrError<any>): value is TError;
export interface ITryMatchingCommandResult<TContext, TExtra> {
    command: IMatchedCommand<TContext, TExtra>;
}
export interface ITryMatchingArgumentsToSignatureResult {
    args: IArgumentMap;
    opts: IMatchedOptionMap;
}
export interface IMatchedCommand<TContext, TExtra> extends ICommandDefinition<TContext, TExtra> {
    args: IArgumentMap;
    opts: IMatchedOptionMap;
    error?: never;
}
export interface IFindMatchingCommandError<TContext, TExtra> {
    error: string;
    command: ICommandDefinition<TContext, TExtra>;
}
export declare type TFindMatchingCommandResult<TContext, TExtra> = IMatchedCommand<TContext, TExtra> | IFindMatchingCommandError<TContext, TExtra>;
export declare function findMatchingCommandResultHasError<TContext, TExtra>(result: TFindMatchingCommandResult<TContext, TExtra>): result is IFindMatchingCommandError<TContext, TExtra>;
export declare type TTypeConverterFn<TContext> = ((value: any) => any) | ((value: any, context: TContext) => any);
